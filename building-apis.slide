Building APIs
The Golang UK Conference, London
21 Aug 2015
Tags: APIs, RESTful, JSON, Data, Golang

Mat Ryer
https://github.com/matryer
@matryer

* About me

- Been coding since age 6
- Been Go-ing since `r59`
- Using Go in anger since 2011
- In love with test-driven development
- Founded *Testify* and other less successful packages
- Just joined GrayMeta, Inc.
- Author of Go Programming Blueprints

.image gopher-mat.png

* Book: Go Programming Blueprints

.image go-blueprints.jpg
.image review.png

[[http://bit.ly/goblueprints]]

* Building APIs

* When you say API...?

Everything is an API - including:

- Packages
  assert.Equal(a, b, "a should equal b")
- Types
  type Worker struct {
  	Stop() <-chan struct{}
  	Start() error
  }
- Functions
  func Something(in io.Reader, out io.Writer) error

* I'm talking about Web APIs

* Before Go

- I used Ruby
- Scaffolding
  script/generate controller mycontroller new create update edit destroy index show
- I like APIs to be quick
- C#.NET took *ages* to write

* Why Go?

- (Very) rapid dev
- Production ready
.code production_ready.go /START OMIT/,/END OMIT/
- We â™¥ Go

* Going

.image trend.png 300 _

Google trend for "Golang"

* Web API design tips

- Don't be clever
- Be boring and obvious
- Impress with functionality
- Talk JSON
- RESTful over HTTP
- Status codes (200 == OK, 404 == Not Found)
- Version it
  GET /api/v1/wonderful-things/
- SSL (HTTPS) every time (check out Cloudflare.com)
- Make output pretty (human readable)
- Use the web (caching)

* Building APIs in Go

- Use the standard library for as long as possible
- You may not need an external package at all
- Use `http.Handler` and `http.HandlerFunc`

.code handler.go

Remember this signature

  func(w http.ResponseWriter, r *http.Request)

* Code explained

.code production_ready.go 

* http.HandlerFunc

.code handlerfunc.go /START OMIT/,/END OMIT/

* Responding

* Grow your own respond function

- Mirror ServeHTTP signature (even though we're not using *http.Request yet)

.code responding.go /START OMIT/,/END OMIT/

* respond package

.code respond-package.go /START OMIT/,/END OMIT/

- see [[https://github.com/matryer/respond]]

* Options for responding

.code respond-options.go /START OMIT/,/END OMIT/

* The Request

* Inside http.Request

`http.Request` contains everything you need to know about the request. 

- `r.Method` - HTTP method (`GET`, `POST`, `PUT`, `PATCH`, `DELETE` etc.)
- `r.URL.Path` - Request path (`/things/123`)
- `r.URL.String()` - Full URL
- `r.URL.Query()` - Query parameters (`q=something&p=2`)
- `r.Body` - io.ReadCloser of the request body

* Routing

.code routes.go /START OMIT/,/END OMIT/

- Standard library until you need something more

Beware:

- / matches *everything*
- No path parameter parsing
- One handler for every HTTP method

You could code this yourself... or maybe it's a good excuse to use a package?

* Routing package

- Gorilla mux - github.com/gorilla/mux

.code gorilla-mux.go /START OMIT/,/END OMIT/

- see also httprouter - github.com/julienschmidt/httprouter (but it breaks the ServeHTTP signature)

* Decoding data from the Request

.code decode.go /START OMIT/,/END OMIT/

- Use `r.Body` (an `io.ReadCloser`)

* Decode helper

.code decode-helper.go /START OMIT/,/END OMIT/

Can be improved later to:

- Check the `Content-Type` header to use different decoders
- Allow URL parameters to influence how the decoder works
- Go a little further and validate the input too...

* OK pattern

Implement a simple interface:

  type ok interface {
    OK() error
  }

Update decode helper:

.code decode-helper-withok.go /START OMIT/,/END OMIT/

* OK pattern example

  type Gopher struct {
    Name string
    Country string
  }

  func (g *Gopher) OK() error {
    if len(g.Name) == 0 {
      return ErrRequired("name")
    }
    if len(g.Country) == 0 {
      return ErrRequired("country")
    }
    return nil
  }

  func handleCreateGopher(w http.ResponseWriter, r *http.Request) error {
  	var g gopher
  	if err := decode(r, &g); err != nil {
  		return err
  	}
  	respond.With(w, r, http.StatusOK, &g)
  	return nil
  }

* Different type for new things

- New things are different to existing things

  type NewGopher struct {
    Name            string
    Email           string
    Password        string
    PasswordConfirm string
  }

  type Gopher struct {
    ID           string `json:"id"`
    Name         string `json:"name"`
    Email        string `json:"email"`
    PasswordHash string `json:"-"`
  }

  // Save saves a NewGopher and returns the Gopher.
  func (g *NewGopher) Save(db *mgo.Database) (*Gopher, error) {

    // ...

  }

* Middleware

* Wrapping handlers (Adapters)

- Run code before and after handler code

.code wrapping.go /START OMIT/,/END OMIT/

* Adapting http.HandlerFunc to handle errors in one place

.code wrapping-funcs.go /START OMIT/,/END OMIT/

See _Twelve_Go_Best_Practices_-_Francesc_Campoy_

* Sharing objects across handlers with context

- Our handler needs a *Logger

.play context-problem.go /START OMIT/,/END OMIT/

- This breaks `http.Handler` interface

Enter Gorilla context package - github.com/gorilla/context

- Provides a `map[string]interface{}` per Request
- Easy to clean up (using its own `http.Handler` wrapper)
- Preserves `ServeHTTP` signature
- Use `context.Set` and `context.Get`

* Real world example: Database connection

Almost every API will interact with some kind of datastore.

We need to:

- Connect when program is first run (expensive)
- Disconnect when the program is terminated
- Create a session per request (cheap)
- Clean up after each request

* MongoDB wrapper using context

.code mongodb.go /START OMIT/,/END OMIT/

* Using the MongoDB wrapper

.code mongodb2.go /START OMIT/,/END OMIT/

* Request lifecycle

- Client hits `GET` `\things`
- `mux.Router` passes the request to `WithDB`
- `WithDB` copies database session and stores it in the context
- `WithDB` then calls `handleThingsRead`
- `handleThingsRead` gets the database session from the context, uses it and responds
- Execution then passes back to `WithDB` which exits and the deferred `Close()` function is called - cleaning up the copy
- `context.ClearHandler` then cleans up the context map for this Request

* Testing

* Unit testing handlers

- Use net/http/httptest from Std lib

.play handler_test.go /START OMIT/,/END OMIT/

* Integration testing (table driven)

.code table_test.go /START OMIT/,/END OMIT/

- Real Go code
- Nothing new to learn

* Table driven tests (runner)

.play table_test2.go /START OMIT/,/END OMIT/

- Making real HTTP requests
- Tests the full stack (including middleware)

* And finally...

* Shout out: Women who go

- https://twitter.com/womenwhogo

.link http://womenwhogo.org womenwhogo.org

* Questions?